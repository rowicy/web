---
title: ドキュメントを追え! mitmproxy編 第一話 ~中間者になるには~
pubDate: '2024-06-01'
description: mitmproxyのドキュメントを読む ep.1
author: RiiiM
tags: [Tech, proxy, Document, mitmproxy]
---

## 勝手にシリーズ始めます

始まりました「 **ドキュメントを追え!** 」シリーズ

なにそれ???

「ドキュメントをわかりやすくかみくだいて説明する記事」と言いたいところですが、**公式ドキュメントを読んで自分で調べた補足を乗っけて行くだけの企画です**

なので自分用の振り返りメモです

## 📖 この記事の読み方

この記事はドキュメントの各セクションで筆者が自分の疑問点を解決したメモのまとめ, いわば **ドキュメントヘルパー** です。

本家ドキュメントと照らし合わせながら補足として参考にすることをおすすめいたします。

## 🚧 注意 🚧
***

当記事では、公式ドキュメントの内容を補足しつつAIの回答を掲載しております。
記事内の補足情報は参考情報としてご活用ください。
最終的なご判断や詳細な確認は、必ず公式資料や専門家の意見をご参照いただきますようお願いいたします。

***

## 本日のドキュメント

### mitmproxyの仕組み

![thumbnail](https://docs.mitmproxy.org/stable/schematics/how-mitmproxy-works-transparent-https.png)

https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/###complication-1-whats-the-remote-hostname

🏃🏻 Let's go !

---

## [問題 1: リモート ホスト名は何ですか?](https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/###complication-1-whats-the-remote-hostname)

> ```
> CONNECT 10.1.1.1:443 HTTP/1.1
> ```
> IP アドレスの使用は、リモート ホスト名が明らかにならなくても、パイプを開始するのに十分な情報が得られるため、完全に正当です。
>
> Mitmproxyには、この手間を省く巧妙なメカニズム、つまり上流証明書スニッフィングが備わっています。CONNECTリクエストを受信するとすぐに、クライアント側の通信を一時停止し、サーバーへの同時接続を開始します。サーバーとのTLSハンドシェイクを完了し、サーバーが使用した証明書を検査します。そして、上流証明書の共通名を使用して、クライアント用のダミー証明書を生成します。これで、ホスト名が指定されていなくても、クライアントに提示できる正しいホスト名が得られます。

### 🧩 問題：リモートホスト名が分からないと証明書が作れない

HTTPS通信では、クライアント（たとえばブラウザ）は接続先の証明書を確認して、**その証明書が本当に接続しようとしているドメインのものか**を検証します。もし違っていたら、「危険なサイト」として接続を中止します。

なので、mitmproxyがクライアントとサーバーの間に割り込むには、**クライアントが期待しているホスト名（ドメイン名）を知る必要がある**んです。



### 🤔 一見すると問題なさそう

たとえばこんなリクエスト：

```
CONNECT example.com:443 HTTP/1.1
```

この場合、ホスト名 `example.com` が書かれているので、それを使って偽の証明書（ダミー証明書）を作ればOKです。



### 🧨 でも、IPアドレス指定されたら？

```
CONNECT 10.1.1.1:443 HTTP/1.1
```

こうなると、**ドメイン名がどこにも書かれていません**。これでも通信は技術的に成り立つのですが、mitmproxyとしては **どのホスト名で証明書を作ればいいかが分からない** という問題が出てきます。



### 🛠️ 解決策：上流証明書スニッフィング（Upstream Certificate Sniffing）

mitmproxyにはこれを解決するための仕組みがあります。

手順としては：

1. クライアントからの `CONNECT` リクエストを受け取ったら、一時的にクライアントとの通信を「停止」。
2. サーバー（この場合 10.1.1.1）に「こっそり」接続して、TLSハンドシェイクを実行。
3. サーバーが返してくる証明書を確認して、その中に書いてあるホスト名（CN: Common Name）を読む。
4. そのホスト名を使って、mitmproxy側で偽の証明書を作成。
5. それをクライアントに提示して通信を再開。



これにより、**たとえクライアントがIPアドレスで接続してきても、正しいドメイン名を取得して傍受が可能になる**というわけです。



* **CONNECT リクエスト**：HTTPS通信でプロキシを通すときに使われるリクエスト。
* **証明書のCN（Common Name）**：証明書に書かれている対象ドメイン名。
* **上流証明書スニッフィング**：サーバーの証明書を先に取得して、それを基にダミー証明書を作る手法。


---

## [問題2: サブジェクト別名](https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/###complication-2-subject-alternative-name)

> 問題はさらに複雑になります。証明書の共通名（CN）が、実際にはクライアントが接続しているホスト名と異なる場合があります。これは、証明書のオプションの「サブジェクト代替名（Subject Alternative Name）」フィールドで任意の数の代替ドメインを指定できるためです。想定されるドメインがこれらのいずれかに一致する場合、ドメインが証明書のCNと一致していなくても、クライアントは処理を続行します。答えは簡単です。アップストリーム証明書からCNを抽出する際に、SANも抽出し、生成されたダミー証明書に追加します。




### 🧩 問題：証明書の「CN」だけじゃ足りないことがある

これまで「証明書のCN（Common Name）を使ってダミー証明書を作ればいいよね」と説明してきましたが、実は **それだけじゃ不十分な場合がある** という話です。



### 🌐 CNと実際のホスト名が違うことがある！

現代のTLS証明書は、**「CN（共通名）」だけじゃなく、「SAN（サブジェクト代替名）」という項目も使っている**のが一般的です。

例えば、証明書にはこんな情報があるかもしれません：

* **CN**: `www.google.com`
* **SAN**: `google.com`, `mail.google.com`, `drive.google.com`

この場合、クライアントが `mail.google.com` に接続していたとしても、**CNが一致しなくても問題ない**んです。SANの中に `mail.google.com` があるので、クライアントは「OK」と判断します。



### 🤔 じゃあ、mitmproxyはどうするべき？

単に「CNを見て偽の証明書を作る」だけだと、**SANにあるホスト名でアクセスしてきたクライアントに対しては警告が出る可能性があります**。



### ✅ 解決策：SANもコピーする！

mitmproxyは、サーバーの証明書から**CNだけでなくSANの中身も全部取得**して、それを **自分が作るダミー証明書にも含めます**。

そうすれば、クライアントがCNに一致しないSANのドメインで接続してきても「正しい証明書だ」と認識してくれるわけです。



* **CN（Common Name）**：証明書の「メインのドメイン名」。
* **SAN（Subject Alternative Name）**：その証明書が有効な他のドメイン名（複数OK）。
* **mitmproxyの対応**：CNもSANも両方ダミー証明書に入れることで、警告を回避。



要するに：

> 「CNだけじゃなくてSANも見てコピーしないと、クライアントにバレちゃうぞ」って話です。

### ✅ SANは**1枚のダミー証明書にそのままコピーされます**

mitmproxyがサーバーから取得した本物の証明書に含まれている **SAN（Subject Alternative Name）フィールドの内容**は、**mitmproxyがクライアントに提示するダミー証明書にもそのまま反映されます（コピーされます）**。

つまり：

* オリジナルの証明書にこう書いてあったら：

  ```
  CN = www.example.com
  SAN = www.example.com, api.example.com, mail.example.net
  ```

* mitmproxyが作るダミー証明書もこうなります：

  ```
  CN = www.example.com
  SAN = www.example.com, api.example.com, mail.example.net
  ```

これにより、クライアントがSANのどのドメイン名でアクセスしてきても「正しい証明書だ」と判断してくれます。



### 🔒 なぜこれが重要か？

ブラウザや多くのクライアントは、**SANにホスト名がないと警告を出す**ようになっています。古い仕様ではCNだけでもOKでしたが、現在は**SANに対象のドメインが含まれているか**が重視されます。



* SANは1枚のダミー証明書に **そのまま全てコピーされる**。
* mitmproxyは、オリジナル証明書の **CNとSANを両方抽出して、偽証明書に反映**。
* こうすることで、どのホスト名でクライアントが接続しても、証明書エラーにならない。


「**現在はSANに対象のドメインが含まれているかが重視される**」のは、以下の理由からです。

### 🔐 背景：CNは曖昧で、セキュリティ上問題があった

かつては証明書の **CN（Common Name）** フィールドだけでホスト名を検証していました。

たとえば：

```text
CN = www.example.com
```

という証明書なら、`www.example.com` への接続はOKと判断されていたわけです。

しかしこの方式には問題がありました。



### 🧨 問題点：CNは仕様的に曖昧だった

* **RFC（仕様）によってCNの扱いに一貫性がなかった**
* 実装によっては **CNが空でも通ってしまう** 場合がある
* 複数ドメインを安全に扱うための方法としては **不十分**
* 証明書発行者が **CNとSANの両方に別の値を入れられる** →混乱や誤用の原因に



### ✅ 解決策：SANを唯一の信頼できる情報源にする

そのため、現在のTLSやX.509証明書の仕様では、以下のように変わりました。

### ✔ 現代のブラウザ・TLSライブラリのルール

* **CNは無視されるか、参考程度**
* **ホスト名の検証には必ずSAN（Subject Alternative Name）を使う**
* SANが無い証明書は**エラーとして扱われる（証明書不備）**

このルールは、ブラウザ・curl・Pythonの`requests`・Java・OpenSSLなど、主要なクライアントで共通です。



### 📜 標準的な裏付け：RFC 6125

RFC 6125（名前ベースの認証ガイドライン）では、次のように書かれています：

> "CN should no longer be used for domain name matching. Clients MUST use the SAN extension instead."

意訳：
「CNはもう使うべきじゃない。クライアントは**必ずSANを使え**」



### 💡 SANが重視される理由

| 理由          | 内容                     |
| --- | --- |
| 🔒 セキュリティ強化 | CNの曖昧さ・誤用を防ぐため         |
| 📜 仕様変更     | RFC 6125などでSANが標準に     |
| 🛠 複数ドメイン対応 | SANは複数のホスト名を正確に管理できる   |
| 🌐 実装の統一    | 主要なブラウザやライブラリでSANしか見ない |




---


## [問題3: サーバー名の表示](https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/###complication-3-server-name-indication)

> ...独立した証明書を持つ複数のドメインが同じIPアドレスを共有する仮想ホスティングは実現できません。IPv4アドレスプールが急速に縮小している現代では、これは大きな問題となります。そこで、 TLSプロトコルのServer Name Indication 拡張機能という形で解決策が提供されています。


### 🔍 概要：SNI(Server Name Indication)とは？

**SNI（Server Name Indication）** は、クライアント（ブラウザなど）がTLS接続を開始するときに、**「自分がアクセスしたいドメイン名」をサーバーに教える**ための拡張機能です。

📌 つまり：
「同じIPアドレスのサーバーに複数のSSL証明書があるとき、どれを出すか決めるための情報」



### 🏠 なぜ必要？

昔は「1つのIPアドレスに1つのSSL証明書」しか使えませんでした。
でも今は、**1つのサーバー（IP）で複数のHTTPSサイトをホストするのが当たり前**です。

### 問題：

TLSでは最初に「証明書」を送る必要がありますが、
証明書を出す前に**どのドメインにアクセスするかが分からない**と、
**正しい証明書を選べない**！



### 🛠️ SNIの仕組み（ざっくり流れ）

1. クライアント（ブラウザなど）がサーバーに接続しようとする
2. TLSのハンドシェイク開始時に、「私は `www.example.com` にアクセスしたいです」と伝える（これがSNI）
3. サーバーはその情報をもとに、`www.example.com` 用の証明書を選んで返す
4. クライアントはその証明書を検証し、TLSセッションを続ける



### 🧱 技術的な位置づけ

* SNIは **TLS ハンドシェイクの ClientHello に含まれる拡張フィールド**。
* TLS 1.0以降で利用可能（現在はTLS 1.2 / 1.3が主流）



### 🌐 実際の活用例

* **バーチャルホスト型のHTTPSサイト**

  * 例: `example.com`, `blog.example.com`, `shop.example.com` がすべて同じサーバー・IP
  * SNIがなければ、どの証明書を使うか判断できない
* **CDNやクラウドサービス**

  * Cloudflare、AWS、Azureなどで大量のドメインを1つのIPに集約



### 🔒 SNIのプライバシー問題

SNIの内容は\*\*平文（暗号化されていない）\*\*なので、通信を覗き見ることができれば、
「ユーザーがどのサイトにアクセスしようとしているか」は見えてしまいます。

→ 対策として **Encrypted SNI（ESNI）** → **ECH（Encrypted Client Hello）** という新しい技術が登場しています。
（ECHはTLS 1.3以降の機能）



| 項目     | 内容                               |
| --- | --- |
| 🔤 名称  | Server Name Indication（SNI）      |
| 🎯 目的  | クライアントがアクセス先のドメインを事前にサーバーに知らせる   |
| 💬 仕組み | TLSハンドシェイク時にClientHelloでドメイン名を送信 |
| 🧠 利点  | 1つのIPで複数のSSL証明書を使い分けられる          |
| ⚠️ 注意点 | 通信先ドメインが盗聴でバレる可能性あり（平文）          |

---


## [透過的なHTTP](https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/#transparent-http)

> 透過プロキシを使用すると、接続はネットワーク層のプロキシにリダイレクトされ、クライアント側の設定は一切必要ありません。そのため、透過プロキシは、クライアントの動作を変更できない状況（プロキシを意識する必要のないAndroidアプリケーションなど）に最適です。


### 📦 透過プロキシを動かすには、2つの追加仕組みが必要！

### ① リダイレクトメカニズム

これは、元々インターネット上のサーバー（例えば `example.com:80`）に行くはずだった通信を、**mitmproxyに横取りして送る仕組み**です。

* Linuxでは → `iptables`
* macOSでは → `pf`

で実現できます。

🔁 つまり：
「この通信、本来の宛先じゃなくて**mitmproxyが待ち受けてる場所**に送ってね」
とネットワークの設定で指示します。



### ② 元の宛先を知る仕組み

横取りされた通信が mitmproxy に来たとき、
リクエストはこんな風に始まります：

```
GET /index.html HTTP/1.1
```

このリクエストには「どこのサイトへのリクエストか（ドメイン名）」が書かれていません！

なぜなら、これは「明示的なプロキシ」じゃなく、普通のクライアントが出した**素のHTTPリクエスト**だからです。

なので mitmproxy は「これ、もともとどこに送ろうとしてた通信なの？」という\*\*元の宛先情報（IPアドレスやポート）\*\*を知る必要があります。

これを可能にするのが **ホストモジュール** です。

* 各OSのネットワーク設定（iptablesやpfなど）から、**元の宛先IPを取得する機能**
* mitmproxyにはそれをやってくれる**組み込みモジュール**が用意されています



### クライアントの設定を変えなくてもプロキシできる仕組みが「透過プロキシ」。

使うには：

| 仕組み      | 役割                                   |
| --- | --- |
| ① リダイレクト | 通信をmitmproxyに送る（iptables/pfなど）       |
| ② 元の宛先取得 | その通信が本来向かっていたサーバーを特定する（mitmproxyが対応） |

この2つがあれば、**クライアントにバレずにHTTPを監視・操作**できるというわけです。


---

## [透過的なHTTPS](https://docs.mitmproxy.org/stable/concepts/how-mitmproxy-works/###transparent-https)

> ここからのプロセスは、これまで説明したHTTPの透過プロキシとHTTPSの明示的プロキシの手法を統合したものです。ルーティングメカニズムを用いて上流サーバーのアドレスを確立し、その後は明示的HTTPS接続と同様にCNとSANを確立し、SNIに対処します。


### 🧭 ステップ①：これはHTTPSか？を判断する

mitmproxyが最初にやるのは：

> ✋「この通信はHTTPSなの？それともHTTPなの？」

そのために、次の2つの方法を使います：



### 方法1：元のポート番号を見る

* 通常、HTTPSはポート`443`を使います。
* mitmproxyはiptablesやpfから「この接続、元々どのポートに向かってた？」を聞いて判断します。



### 方法2：ClientHelloを見る（プロトコルを自動検出）

* TLS通信は最初に「ClientHello」という**決まり文句のようなメッセージ**を送ります。
* mitmproxyは接続の頭をちょっと読んで、それがTLSかどうかを**中身を見て自動で判断**します。

これにより、仮に443番以外のポートでTLSを使っていても検出できます。



### 🧩 ステップ②：HTTPS通信を処理する

ここからは、前に説明した：

* **HTTPの透過プロキシの仕組み**
* **HTTPSの明示的プロキシの処理（SNIとかCNとかSANとか）**

を**合体させた流れ**になります。


### 🔒 注意点（現実）

* クライアント側に**mitmproxyのCA証明書をインストール**していないと、証明書エラーになります
* Android/iOSアプリは**証明書ピンニング**でmitmproxyを拒否することもあります


| ステップ          | 内容                         |
| --- | --- |
| ① HTTPSかどうか判定 | ポート番号 or ClientHello を見て判断 |
| ② 元の宛先取得      | iptables/pfから元の接続先情報をもらう   |
| ③ 上流サーバーに接続   | TLSハンドシェイクで本物の証明書を取得       |
| ④ ダミー証明書作成    | CN・SAN・SNIを反映してクライアントに提示   |
| ⑤ 中継          | 通信を復号して読み取れるようになる          |

この「**元の宛先IPとポートを取得（iptables/pfから）**」という部分は、**透過プロキシの最重要ポイント**の一つです。



### 🔄 背景：なぜ「元の宛先」が必要なの？

透過プロキシでは、クライアント（スマホやPC）が `example.com:443` に接続しようとしている通信を、
ネットワークの設定（iptables や pf）で横取りして mitmproxy に流します。

でもこのとき、mitmproxyはこうなります：

> 🤔「この通信、本来どこのサーバーに行くはずだったんだろう？」

それを知らないと、上流（本物のサーバー）に接続してリレーできません。



### 🔧 じゃあどうやって「元の宛先」を知るの？

iptables や pf などの **リダイレクト設定をした仕組み**は、
「この接続はどこから来て、どこに行く予定だったか」
という情報をカーネルレベルで**記録している**んです。

mitmproxy はそれを OSごとの方法で問い合わせて、元の宛先を取得します。



### 🛠️ OS別の仕組み（例）

| OS          | リダイレクト方法                | 元の宛先を取得する方法                                   |
| --- | --- | ---|
| Linux       | `iptables` + `REDIRECT` | `getsockopt()` システムコールで `SO_ORIGINAL_DST` を取得 |
| macOS / BSD | `pf`（Packet Filter）     | `getsockname()` で NAT テーブルから取得（やや複雑）          |

### 🔍 Linuxの例（iptables）

```bash
### すべての443番ポート宛てのTCP通信をmitmproxyのポート（例: 8080）に転送
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8080
```

これでリダイレクトされた接続に対して、mitmproxyがこう問い合わせます：

```c
getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, ...)
```

すると、「この接続は本来 `example.com:443` に行く予定だったよ」と教えてくれます。



### 🧠 mitmproxyの役割

mitmproxyは OSのAPI を使って**リダイレクト元の情報を取得できるように作られていて**、
「この接続は `10.1.1.20:443` に向かっていた」みたいな情報をもとに、
実際に上流サーバーと通信を開始します。



### 🎯 なぜ重要なのか？

HTTPの場合はリクエストにホスト名が書かれていることが多いですが、
HTTPSの場合は**暗号化されていて中身が見えません**。
だから、**「元々どこに接続しようとしてたのか」をOSから聞き出すしかない**んです。


| ポイント        | 内容                                          |
| --- | --- |
| なぜ必要？       | mitmproxyは「元の接続先」を知らないと中継できない               |
| 誰が知ってる？     | iptablesやpfなどのリダイレクトシステム                    |
| どうやって知る？    | OSのAPI（Linuxなら `SO_ORIGINAL_DST`）を使って問い合わせる |
| mitmproxyは？ | OSごとに実装された「元の宛先取得モジュール」で処理している              |



以下に、Linuxで `SO_ORIGINAL_DST` を使って「リダイレクト前の元の宛先IPアドレスとポート番号」を取得する **Pythonコードのシンプルな例** を紹介します。

---

## 追加情報


### `SO_ORIGINAL_DST` を使った Pythonコード

* OS: **Linux**
* Python: 3.x
* ソケットは **iptables で REDIRECT された接続**から受け取ったもの
* 必要なモジュール：`socket`, `struct`, `ctypes`



### 📜 Pythonコード例：`SO_ORIGINAL_DST` を取得

* **Linux限定です。macOSやWindowsではこの方法は使えません。**
* `SO_ORIGINAL_DST` は root 権限が必要になる場合があります。
* このコードを使う前に、iptables でリダイレクト設定を済ませておく必要があります。

```python
import socket
import struct

### SO_ORIGINAL_DST の定数 (Linux固有)
SO_ORIGINAL_DST = 80  ### <netinet/in.h> で定義されている

def get_original_dst(conn: socket.socket):
    ### IP + ポート = 16バイト（sockaddr_in 構造体）
    raw = conn.getsockopt(socket.SOL_IP, SO_ORIGINAL_DST, 16)
    
    ### sockaddr_in の構造体に合わせてアンパック
    port, ip = struct.unpack_from("!xH4s", raw)
    ip_str = socket.inet_ntoa(ip)
    
    return ip_str, port

### 例: 受信したTCP接続に対して使用
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
    server.bind(('0.0.0.0', 8080))  ### iptables で転送された先のポート
    server.listen(5)
    print("Listening on port 8080...")

    conn, addr = server.accept()
    with conn:
        print(f"Incoming connection from {addr}")

        ### 元の宛先（リダイレクト前）を取得
        original_ip, original_port = get_original_dst(conn)
        print(f"Original destination was: {original_ip}:{original_port}")
```



### 🧪 動作確認の例（iptables設定）

```bash
### 例: 443番宛ての通信をmitmproxyやこのスクリプトのポート8080に転送
sudo iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8080
```

---

## 感想

mitmは `man in the middle` (中間者) という意味です。

今回のドキュメントを見てHTTP通信の中間者になるためにツールに何が必要かがわかると思います。

---

## 次回

https://docs.mitmproxy.org/stable/concepts/certificates/

**証明書について**

これでも読みます。

